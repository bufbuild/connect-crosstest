// Copyright 2020-2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-connect-go. DO NOT EDIT.
// versions:
// - protoc-gen-connect-go v0.0.1
// - protoc              (unknown)
// source: grpc/testing/test.proto

package testing

import (
	context "context"
	errors "errors"
	connect "github.com/bufbuild/connect"
	testing "github.com/bufbuild/connect-crosstest/internal/gen/proto/go/grpc/testing"
	http "net/http"
	path "path"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant isn't defined, this code was generated
// with a version of connect newer than the one compiled into your binary. You can fix the problem
// by either regenerating this code with an older version of connect or updating the connect version
// compiled into your binary.
const _ = connect.IsAtLeastVersion0_0_1

// TestServiceClient is a client for the grpc.testing.TestService service.
type TestServiceClient interface {
	// One empty request followed by one empty response.
	EmptyCall(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
	// One request followed by one response.
	UnaryCall(context.Context, *connect.Envelope[testing.SimpleRequest]) (*connect.Envelope[testing.SimpleResponse], error)
	// One request followed by one response. Response has cache control
	// headers set such that a caching HTTP proxy (such as GFE) can
	// satisfy subsequent requests.
	CacheableUnaryCall(context.Context, *connect.Envelope[testing.SimpleRequest]) (*connect.Envelope[testing.SimpleResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	StreamingOutputCall(context.Context, *connect.Envelope[testing.StreamingOutputCallRequest]) (*connect.ServerStreamForClient[testing.StreamingOutputCallResponse], error)
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the aggregated size of client payload as the result.
	StreamingInputCall(context.Context) *connect.ClientStreamForClient[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse]
	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	FullDuplexCall(context.Context) *connect.BidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client requests and then serves them in order. A
	// stream of responses are returned to the client when the server starts with
	// first request.
	HalfDuplexCall(context.Context) *connect.BidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented methods.
	UnimplementedCall(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
}

// NewTestServiceClient constructs a client for the grpc.testing.TestService service. By default, it
// uses the binary protobuf codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g., https://api.acme.com or
// https://acme.com/grpc).
func NewTestServiceClient(baseURL string, doer connect.Doer, opts ...connect.ClientOption) (TestServiceClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]connect.ClientOption{
		connect.WithProtoBinaryCodec(),
		connect.WithGzip(),
	}, opts...)
	var (
		client testServiceClient
		err    error
	)
	client.emptyCall, err = connect.NewUnaryClientImplementation[testing.Empty, testing.Empty](
		doer,
		baseURL,
		"grpc.testing.TestService/EmptyCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.unaryCall, err = connect.NewUnaryClientImplementation[testing.SimpleRequest, testing.SimpleResponse](
		doer,
		baseURL,
		"grpc.testing.TestService/UnaryCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.cacheableUnaryCall, err = connect.NewUnaryClientImplementation[testing.SimpleRequest, testing.SimpleResponse](
		doer,
		baseURL,
		"grpc.testing.TestService/CacheableUnaryCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.streamingOutputCall, err = connect.NewStreamClientImplementation(
		doer,
		baseURL,
		"grpc.testing.TestService/StreamingOutputCall",
		connect.StreamTypeServer,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.streamingInputCall, err = connect.NewStreamClientImplementation(
		doer,
		baseURL,
		"grpc.testing.TestService/StreamingInputCall",
		connect.StreamTypeClient,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.fullDuplexCall, err = connect.NewStreamClientImplementation(
		doer,
		baseURL,
		"grpc.testing.TestService/FullDuplexCall",
		connect.StreamTypeBidirectional,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.halfDuplexCall, err = connect.NewStreamClientImplementation(
		doer,
		baseURL,
		"grpc.testing.TestService/HalfDuplexCall",
		connect.StreamTypeBidirectional,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.unimplementedCall, err = connect.NewUnaryClientImplementation[testing.Empty, testing.Empty](
		doer,
		baseURL,
		"grpc.testing.TestService/UnimplementedCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &client, nil
}

// testServiceClient implements TestServiceClient.
type testServiceClient struct {
	emptyCall           func(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
	unaryCall           func(context.Context, *connect.Envelope[testing.SimpleRequest]) (*connect.Envelope[testing.SimpleResponse], error)
	cacheableUnaryCall  func(context.Context, *connect.Envelope[testing.SimpleRequest]) (*connect.Envelope[testing.SimpleResponse], error)
	streamingOutputCall func(context.Context) (connect.Sender, connect.Receiver)
	streamingInputCall  func(context.Context) (connect.Sender, connect.Receiver)
	fullDuplexCall      func(context.Context) (connect.Sender, connect.Receiver)
	halfDuplexCall      func(context.Context) (connect.Sender, connect.Receiver)
	unimplementedCall   func(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
}

var _ TestServiceClient = (*testServiceClient)(nil) // verify interface implementation

// EmptyCall calls grpc.testing.TestService.EmptyCall.
func (c *testServiceClient) EmptyCall(ctx context.Context, req *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error) {
	return c.emptyCall(ctx, req)
}

// UnaryCall calls grpc.testing.TestService.UnaryCall.
func (c *testServiceClient) UnaryCall(ctx context.Context, req *connect.Envelope[testing.SimpleRequest]) (*connect.Envelope[testing.SimpleResponse], error) {
	return c.unaryCall(ctx, req)
}

// CacheableUnaryCall calls grpc.testing.TestService.CacheableUnaryCall.
func (c *testServiceClient) CacheableUnaryCall(ctx context.Context, req *connect.Envelope[testing.SimpleRequest]) (*connect.Envelope[testing.SimpleResponse], error) {
	return c.cacheableUnaryCall(ctx, req)
}

// StreamingOutputCall calls grpc.testing.TestService.StreamingOutputCall.
func (c *testServiceClient) StreamingOutputCall(ctx context.Context, req *connect.Envelope[testing.StreamingOutputCallRequest]) (*connect.ServerStreamForClient[testing.StreamingOutputCallResponse], error) {
	sender, receiver := c.streamingOutputCall(ctx)
	for key, values := range req.Header() {
		sender.Header()[key] = append(sender.Header()[key], values...)
	}
	for key, values := range req.Trailer() {
		sender.Trailer()[key] = append(sender.Trailer()[key], values...)
	}
	if err := sender.Send(req.Msg); err != nil {
		_ = sender.Close(err)
		_ = receiver.Close()
		return nil, err
	}
	if err := sender.Close(nil); err != nil {
		_ = receiver.Close()
		return nil, err
	}
	return connect.NewServerStreamForClient[testing.StreamingOutputCallResponse](receiver), nil
}

// StreamingInputCall calls grpc.testing.TestService.StreamingInputCall.
func (c *testServiceClient) StreamingInputCall(ctx context.Context) *connect.ClientStreamForClient[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse] {
	sender, receiver := c.streamingInputCall(ctx)
	return connect.NewClientStreamForClient[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse](sender, receiver)
}

// FullDuplexCall calls grpc.testing.TestService.FullDuplexCall.
func (c *testServiceClient) FullDuplexCall(ctx context.Context) *connect.BidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse] {
	sender, receiver := c.fullDuplexCall(ctx)
	return connect.NewBidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](sender, receiver)
}

// HalfDuplexCall calls grpc.testing.TestService.HalfDuplexCall.
func (c *testServiceClient) HalfDuplexCall(ctx context.Context) *connect.BidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse] {
	sender, receiver := c.halfDuplexCall(ctx)
	return connect.NewBidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](sender, receiver)
}

// UnimplementedCall calls grpc.testing.TestService.UnimplementedCall.
func (c *testServiceClient) UnimplementedCall(ctx context.Context, req *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error) {
	return c.unimplementedCall(ctx, req)
}

// TestServiceHandler is an implementation of the grpc.testing.TestService service.
type TestServiceHandler interface {
	// One empty request followed by one empty response.
	EmptyCall(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
	// One request followed by one response.
	UnaryCall(context.Context, *connect.Envelope[testing.SimpleRequest]) (*connect.Envelope[testing.SimpleResponse], error)
	// One request followed by one response. Response has cache control
	// headers set such that a caching HTTP proxy (such as GFE) can
	// satisfy subsequent requests.
	CacheableUnaryCall(context.Context, *connect.Envelope[testing.SimpleRequest]) (*connect.Envelope[testing.SimpleResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	StreamingOutputCall(context.Context, *connect.Envelope[testing.StreamingOutputCallRequest], *connect.ServerStream[testing.StreamingOutputCallResponse]) error
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the aggregated size of client payload as the result.
	StreamingInputCall(context.Context, *connect.ClientStream[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse]) error
	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	FullDuplexCall(context.Context, *connect.BidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client requests and then serves them in order. A
	// stream of responses are returned to the client when the server starts with
	// first request.
	HalfDuplexCall(context.Context, *connect.BidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented methods.
	UnimplementedCall(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
}

// NewTestServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the gRPC and gRPC-Web protocols with the binary protobuf and JSON
// codecs.
func NewTestServiceHandler(svc TestServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	var lastHandlerPath string
	mux := http.NewServeMux()
	opts = append([]connect.HandlerOption{
		connect.WithProtoBinaryCodec(),
		connect.WithProtoJSONCodec(),
		connect.WithGzip(),
	}, opts...)

	emptyCall := connect.NewUnaryHandler(
		"grpc.testing.TestService/EmptyCall", // procedure name
		"grpc.testing.TestService",           // reflection name
		svc.EmptyCall,
		opts...,
	)
	mux.Handle(emptyCall.Path(), emptyCall)
	lastHandlerPath = emptyCall.Path()

	unaryCall := connect.NewUnaryHandler(
		"grpc.testing.TestService/UnaryCall", // procedure name
		"grpc.testing.TestService",           // reflection name
		svc.UnaryCall,
		opts...,
	)
	mux.Handle(unaryCall.Path(), unaryCall)
	lastHandlerPath = unaryCall.Path()

	cacheableUnaryCall := connect.NewUnaryHandler(
		"grpc.testing.TestService/CacheableUnaryCall", // procedure name
		"grpc.testing.TestService",                    // reflection name
		svc.CacheableUnaryCall,
		opts...,
	)
	mux.Handle(cacheableUnaryCall.Path(), cacheableUnaryCall)
	lastHandlerPath = cacheableUnaryCall.Path()

	streamingOutputCall := connect.NewStreamHandler(
		"grpc.testing.TestService/StreamingOutputCall", // procedure name
		"grpc.testing.TestService",                     // reflection name
		connect.StreamTypeServer,
		func(ctx context.Context, sender connect.Sender, receiver connect.Receiver) {
			typed := connect.NewServerStream[testing.StreamingOutputCallResponse](sender)
			req, err := connect.ReceiveUnaryEnvelope[testing.StreamingOutputCallRequest](receiver)
			if err != nil {
				_ = receiver.Close()
				_ = sender.Close(err)
				return
			}
			if err = receiver.Close(); err != nil {
				_ = sender.Close(err)
				return
			}
			err = svc.StreamingOutputCall(ctx, req, typed)
			_ = sender.Close(err)
		},
		opts...,
	)
	mux.Handle(streamingOutputCall.Path(), streamingOutputCall)
	lastHandlerPath = streamingOutputCall.Path()

	streamingInputCall := connect.NewStreamHandler(
		"grpc.testing.TestService/StreamingInputCall", // procedure name
		"grpc.testing.TestService",                    // reflection name
		connect.StreamTypeClient,
		func(ctx context.Context, sender connect.Sender, receiver connect.Receiver) {
			typed := connect.NewClientStream[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse](sender, receiver)
			err := svc.StreamingInputCall(ctx, typed)
			_ = receiver.Close()
			_ = sender.Close(err)
		},
		opts...,
	)
	mux.Handle(streamingInputCall.Path(), streamingInputCall)
	lastHandlerPath = streamingInputCall.Path()

	fullDuplexCall := connect.NewStreamHandler(
		"grpc.testing.TestService/FullDuplexCall", // procedure name
		"grpc.testing.TestService",                // reflection name
		connect.StreamTypeBidirectional,
		func(ctx context.Context, sender connect.Sender, receiver connect.Receiver) {
			typed := connect.NewBidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](sender, receiver)
			err := svc.FullDuplexCall(ctx, typed)
			_ = receiver.Close()
			_ = sender.Close(err)
		},
		opts...,
	)
	mux.Handle(fullDuplexCall.Path(), fullDuplexCall)
	lastHandlerPath = fullDuplexCall.Path()

	halfDuplexCall := connect.NewStreamHandler(
		"grpc.testing.TestService/HalfDuplexCall", // procedure name
		"grpc.testing.TestService",                // reflection name
		connect.StreamTypeBidirectional,
		func(ctx context.Context, sender connect.Sender, receiver connect.Receiver) {
			typed := connect.NewBidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](sender, receiver)
			err := svc.HalfDuplexCall(ctx, typed)
			_ = receiver.Close()
			_ = sender.Close(err)
		},
		opts...,
	)
	mux.Handle(halfDuplexCall.Path(), halfDuplexCall)
	lastHandlerPath = halfDuplexCall.Path()

	unimplementedCall := connect.NewUnaryHandler(
		"grpc.testing.TestService/UnimplementedCall", // procedure name
		"grpc.testing.TestService",                   // reflection name
		svc.UnimplementedCall,
		opts...,
	)
	mux.Handle(unimplementedCall.Path(), unimplementedCall)
	lastHandlerPath = unimplementedCall.Path()

	return path.Dir(lastHandlerPath) + "/", mux
}

// UnimplementedTestServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedTestServiceHandler struct{}

var _ TestServiceHandler = (*UnimplementedTestServiceHandler)(nil) // verify interface implementation

func (UnimplementedTestServiceHandler) EmptyCall(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.TestService.EmptyCall isn't implemented"))
}

func (UnimplementedTestServiceHandler) UnaryCall(context.Context, *connect.Envelope[testing.SimpleRequest]) (*connect.Envelope[testing.SimpleResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.TestService.UnaryCall isn't implemented"))
}

func (UnimplementedTestServiceHandler) CacheableUnaryCall(context.Context, *connect.Envelope[testing.SimpleRequest]) (*connect.Envelope[testing.SimpleResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.TestService.CacheableUnaryCall isn't implemented"))
}

func (UnimplementedTestServiceHandler) StreamingOutputCall(context.Context, *connect.Envelope[testing.StreamingOutputCallRequest], *connect.ServerStream[testing.StreamingOutputCallResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.TestService.StreamingOutputCall isn't implemented"))
}

func (UnimplementedTestServiceHandler) StreamingInputCall(context.Context, *connect.ClientStream[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.TestService.StreamingInputCall isn't implemented"))
}

func (UnimplementedTestServiceHandler) FullDuplexCall(context.Context, *connect.BidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.TestService.FullDuplexCall isn't implemented"))
}

func (UnimplementedTestServiceHandler) HalfDuplexCall(context.Context, *connect.BidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.TestService.HalfDuplexCall isn't implemented"))
}

func (UnimplementedTestServiceHandler) UnimplementedCall(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.TestService.UnimplementedCall isn't implemented"))
}

// UnimplementedServiceClient is a client for the grpc.testing.UnimplementedService service.
type UnimplementedServiceClient interface {
	// A call that no server should implement
	UnimplementedCall(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
}

// NewUnimplementedServiceClient constructs a client for the grpc.testing.UnimplementedService
// service. By default, it uses the binary protobuf codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g., https://api.acme.com or
// https://acme.com/grpc).
func NewUnimplementedServiceClient(baseURL string, doer connect.Doer, opts ...connect.ClientOption) (UnimplementedServiceClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]connect.ClientOption{
		connect.WithProtoBinaryCodec(),
		connect.WithGzip(),
	}, opts...)
	var (
		client unimplementedServiceClient
		err    error
	)
	client.unimplementedCall, err = connect.NewUnaryClientImplementation[testing.Empty, testing.Empty](
		doer,
		baseURL,
		"grpc.testing.UnimplementedService/UnimplementedCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &client, nil
}

// unimplementedServiceClient implements UnimplementedServiceClient.
type unimplementedServiceClient struct {
	unimplementedCall func(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
}

var _ UnimplementedServiceClient = (*unimplementedServiceClient)(nil) // verify interface implementation

// UnimplementedCall calls grpc.testing.UnimplementedService.UnimplementedCall.
func (c *unimplementedServiceClient) UnimplementedCall(ctx context.Context, req *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error) {
	return c.unimplementedCall(ctx, req)
}

// UnimplementedServiceHandler is an implementation of the grpc.testing.UnimplementedService
// service.
type UnimplementedServiceHandler interface {
	// A call that no server should implement
	UnimplementedCall(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
}

// NewUnimplementedServiceHandler builds an HTTP handler from the service implementation. It returns
// the path on which to mount the handler and the handler itself.
//
// By default, handlers support the gRPC and gRPC-Web protocols with the binary protobuf and JSON
// codecs.
func NewUnimplementedServiceHandler(svc UnimplementedServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	var lastHandlerPath string
	mux := http.NewServeMux()
	opts = append([]connect.HandlerOption{
		connect.WithProtoBinaryCodec(),
		connect.WithProtoJSONCodec(),
		connect.WithGzip(),
	}, opts...)

	unimplementedCall := connect.NewUnaryHandler(
		"grpc.testing.UnimplementedService/UnimplementedCall", // procedure name
		"grpc.testing.UnimplementedService",                   // reflection name
		svc.UnimplementedCall,
		opts...,
	)
	mux.Handle(unimplementedCall.Path(), unimplementedCall)
	lastHandlerPath = unimplementedCall.Path()

	return path.Dir(lastHandlerPath) + "/", mux
}

// UnimplementedUnimplementedServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedUnimplementedServiceHandler struct{}

var _ UnimplementedServiceHandler = (*UnimplementedUnimplementedServiceHandler)(nil) // verify interface implementation

func (UnimplementedUnimplementedServiceHandler) UnimplementedCall(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.UnimplementedService.UnimplementedCall isn't implemented"))
}

// ReconnectServiceClient is a client for the grpc.testing.ReconnectService service.
type ReconnectServiceClient interface {
	Start(context.Context, *connect.Envelope[testing.ReconnectParams]) (*connect.Envelope[testing.Empty], error)
	Stop(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.ReconnectInfo], error)
}

// NewReconnectServiceClient constructs a client for the grpc.testing.ReconnectService service. By
// default, it uses the binary protobuf codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g., https://api.acme.com or
// https://acme.com/grpc).
func NewReconnectServiceClient(baseURL string, doer connect.Doer, opts ...connect.ClientOption) (ReconnectServiceClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]connect.ClientOption{
		connect.WithProtoBinaryCodec(),
		connect.WithGzip(),
	}, opts...)
	var (
		client reconnectServiceClient
		err    error
	)
	client.start, err = connect.NewUnaryClientImplementation[testing.ReconnectParams, testing.Empty](
		doer,
		baseURL,
		"grpc.testing.ReconnectService/Start",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.stop, err = connect.NewUnaryClientImplementation[testing.Empty, testing.ReconnectInfo](
		doer,
		baseURL,
		"grpc.testing.ReconnectService/Stop",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &client, nil
}

// reconnectServiceClient implements ReconnectServiceClient.
type reconnectServiceClient struct {
	start func(context.Context, *connect.Envelope[testing.ReconnectParams]) (*connect.Envelope[testing.Empty], error)
	stop  func(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.ReconnectInfo], error)
}

var _ ReconnectServiceClient = (*reconnectServiceClient)(nil) // verify interface implementation

// Start calls grpc.testing.ReconnectService.Start.
func (c *reconnectServiceClient) Start(ctx context.Context, req *connect.Envelope[testing.ReconnectParams]) (*connect.Envelope[testing.Empty], error) {
	return c.start(ctx, req)
}

// Stop calls grpc.testing.ReconnectService.Stop.
func (c *reconnectServiceClient) Stop(ctx context.Context, req *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.ReconnectInfo], error) {
	return c.stop(ctx, req)
}

// ReconnectServiceHandler is an implementation of the grpc.testing.ReconnectService service.
type ReconnectServiceHandler interface {
	Start(context.Context, *connect.Envelope[testing.ReconnectParams]) (*connect.Envelope[testing.Empty], error)
	Stop(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.ReconnectInfo], error)
}

// NewReconnectServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the gRPC and gRPC-Web protocols with the binary protobuf and JSON
// codecs.
func NewReconnectServiceHandler(svc ReconnectServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	var lastHandlerPath string
	mux := http.NewServeMux()
	opts = append([]connect.HandlerOption{
		connect.WithProtoBinaryCodec(),
		connect.WithProtoJSONCodec(),
		connect.WithGzip(),
	}, opts...)

	start := connect.NewUnaryHandler(
		"grpc.testing.ReconnectService/Start", // procedure name
		"grpc.testing.ReconnectService",       // reflection name
		svc.Start,
		opts...,
	)
	mux.Handle(start.Path(), start)
	lastHandlerPath = start.Path()

	stop := connect.NewUnaryHandler(
		"grpc.testing.ReconnectService/Stop", // procedure name
		"grpc.testing.ReconnectService",      // reflection name
		svc.Stop,
		opts...,
	)
	mux.Handle(stop.Path(), stop)
	lastHandlerPath = stop.Path()

	return path.Dir(lastHandlerPath) + "/", mux
}

// UnimplementedReconnectServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedReconnectServiceHandler struct{}

var _ ReconnectServiceHandler = (*UnimplementedReconnectServiceHandler)(nil) // verify interface implementation

func (UnimplementedReconnectServiceHandler) Start(context.Context, *connect.Envelope[testing.ReconnectParams]) (*connect.Envelope[testing.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.ReconnectService.Start isn't implemented"))
}

func (UnimplementedReconnectServiceHandler) Stop(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.ReconnectInfo], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.ReconnectService.Stop isn't implemented"))
}

// LoadBalancerStatsServiceClient is a client for the grpc.testing.LoadBalancerStatsService service.
type LoadBalancerStatsServiceClient interface {
	// Gets the backend distribution for RPCs sent by a test client.
	GetClientStats(context.Context, *connect.Envelope[testing.LoadBalancerStatsRequest]) (*connect.Envelope[testing.LoadBalancerStatsResponse], error)
	// Gets the accumulated stats for RPCs sent by a test client.
	GetClientAccumulatedStats(context.Context, *connect.Envelope[testing.LoadBalancerAccumulatedStatsRequest]) (*connect.Envelope[testing.LoadBalancerAccumulatedStatsResponse], error)
}

// NewLoadBalancerStatsServiceClient constructs a client for the
// grpc.testing.LoadBalancerStatsService service. By default, it uses the binary protobuf codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g., https://api.acme.com or
// https://acme.com/grpc).
func NewLoadBalancerStatsServiceClient(baseURL string, doer connect.Doer, opts ...connect.ClientOption) (LoadBalancerStatsServiceClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]connect.ClientOption{
		connect.WithProtoBinaryCodec(),
		connect.WithGzip(),
	}, opts...)
	var (
		client loadBalancerStatsServiceClient
		err    error
	)
	client.getClientStats, err = connect.NewUnaryClientImplementation[testing.LoadBalancerStatsRequest, testing.LoadBalancerStatsResponse](
		doer,
		baseURL,
		"grpc.testing.LoadBalancerStatsService/GetClientStats",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.getClientAccumulatedStats, err = connect.NewUnaryClientImplementation[testing.LoadBalancerAccumulatedStatsRequest, testing.LoadBalancerAccumulatedStatsResponse](
		doer,
		baseURL,
		"grpc.testing.LoadBalancerStatsService/GetClientAccumulatedStats",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &client, nil
}

// loadBalancerStatsServiceClient implements LoadBalancerStatsServiceClient.
type loadBalancerStatsServiceClient struct {
	getClientStats            func(context.Context, *connect.Envelope[testing.LoadBalancerStatsRequest]) (*connect.Envelope[testing.LoadBalancerStatsResponse], error)
	getClientAccumulatedStats func(context.Context, *connect.Envelope[testing.LoadBalancerAccumulatedStatsRequest]) (*connect.Envelope[testing.LoadBalancerAccumulatedStatsResponse], error)
}

var _ LoadBalancerStatsServiceClient = (*loadBalancerStatsServiceClient)(nil) // verify interface implementation

// GetClientStats calls grpc.testing.LoadBalancerStatsService.GetClientStats.
func (c *loadBalancerStatsServiceClient) GetClientStats(ctx context.Context, req *connect.Envelope[testing.LoadBalancerStatsRequest]) (*connect.Envelope[testing.LoadBalancerStatsResponse], error) {
	return c.getClientStats(ctx, req)
}

// GetClientAccumulatedStats calls grpc.testing.LoadBalancerStatsService.GetClientAccumulatedStats.
func (c *loadBalancerStatsServiceClient) GetClientAccumulatedStats(ctx context.Context, req *connect.Envelope[testing.LoadBalancerAccumulatedStatsRequest]) (*connect.Envelope[testing.LoadBalancerAccumulatedStatsResponse], error) {
	return c.getClientAccumulatedStats(ctx, req)
}

// LoadBalancerStatsServiceHandler is an implementation of the grpc.testing.LoadBalancerStatsService
// service.
type LoadBalancerStatsServiceHandler interface {
	// Gets the backend distribution for RPCs sent by a test client.
	GetClientStats(context.Context, *connect.Envelope[testing.LoadBalancerStatsRequest]) (*connect.Envelope[testing.LoadBalancerStatsResponse], error)
	// Gets the accumulated stats for RPCs sent by a test client.
	GetClientAccumulatedStats(context.Context, *connect.Envelope[testing.LoadBalancerAccumulatedStatsRequest]) (*connect.Envelope[testing.LoadBalancerAccumulatedStatsResponse], error)
}

// NewLoadBalancerStatsServiceHandler builds an HTTP handler from the service implementation. It
// returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the gRPC and gRPC-Web protocols with the binary protobuf and JSON
// codecs.
func NewLoadBalancerStatsServiceHandler(svc LoadBalancerStatsServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	var lastHandlerPath string
	mux := http.NewServeMux()
	opts = append([]connect.HandlerOption{
		connect.WithProtoBinaryCodec(),
		connect.WithProtoJSONCodec(),
		connect.WithGzip(),
	}, opts...)

	getClientStats := connect.NewUnaryHandler(
		"grpc.testing.LoadBalancerStatsService/GetClientStats", // procedure name
		"grpc.testing.LoadBalancerStatsService",                // reflection name
		svc.GetClientStats,
		opts...,
	)
	mux.Handle(getClientStats.Path(), getClientStats)
	lastHandlerPath = getClientStats.Path()

	getClientAccumulatedStats := connect.NewUnaryHandler(
		"grpc.testing.LoadBalancerStatsService/GetClientAccumulatedStats", // procedure name
		"grpc.testing.LoadBalancerStatsService",                           // reflection name
		svc.GetClientAccumulatedStats,
		opts...,
	)
	mux.Handle(getClientAccumulatedStats.Path(), getClientAccumulatedStats)
	lastHandlerPath = getClientAccumulatedStats.Path()

	return path.Dir(lastHandlerPath) + "/", mux
}

// UnimplementedLoadBalancerStatsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedLoadBalancerStatsServiceHandler struct{}

var _ LoadBalancerStatsServiceHandler = (*UnimplementedLoadBalancerStatsServiceHandler)(nil) // verify interface implementation

func (UnimplementedLoadBalancerStatsServiceHandler) GetClientStats(context.Context, *connect.Envelope[testing.LoadBalancerStatsRequest]) (*connect.Envelope[testing.LoadBalancerStatsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.LoadBalancerStatsService.GetClientStats isn't implemented"))
}

func (UnimplementedLoadBalancerStatsServiceHandler) GetClientAccumulatedStats(context.Context, *connect.Envelope[testing.LoadBalancerAccumulatedStatsRequest]) (*connect.Envelope[testing.LoadBalancerAccumulatedStatsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.LoadBalancerStatsService.GetClientAccumulatedStats isn't implemented"))
}

// XdsUpdateHealthServiceClient is a client for the grpc.testing.XdsUpdateHealthService service.
type XdsUpdateHealthServiceClient interface {
	SetServing(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
	SetNotServing(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
}

// NewXdsUpdateHealthServiceClient constructs a client for the grpc.testing.XdsUpdateHealthService
// service. By default, it uses the binary protobuf codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g., https://api.acme.com or
// https://acme.com/grpc).
func NewXdsUpdateHealthServiceClient(baseURL string, doer connect.Doer, opts ...connect.ClientOption) (XdsUpdateHealthServiceClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]connect.ClientOption{
		connect.WithProtoBinaryCodec(),
		connect.WithGzip(),
	}, opts...)
	var (
		client xdsUpdateHealthServiceClient
		err    error
	)
	client.setServing, err = connect.NewUnaryClientImplementation[testing.Empty, testing.Empty](
		doer,
		baseURL,
		"grpc.testing.XdsUpdateHealthService/SetServing",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.setNotServing, err = connect.NewUnaryClientImplementation[testing.Empty, testing.Empty](
		doer,
		baseURL,
		"grpc.testing.XdsUpdateHealthService/SetNotServing",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &client, nil
}

// xdsUpdateHealthServiceClient implements XdsUpdateHealthServiceClient.
type xdsUpdateHealthServiceClient struct {
	setServing    func(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
	setNotServing func(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
}

var _ XdsUpdateHealthServiceClient = (*xdsUpdateHealthServiceClient)(nil) // verify interface implementation

// SetServing calls grpc.testing.XdsUpdateHealthService.SetServing.
func (c *xdsUpdateHealthServiceClient) SetServing(ctx context.Context, req *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error) {
	return c.setServing(ctx, req)
}

// SetNotServing calls grpc.testing.XdsUpdateHealthService.SetNotServing.
func (c *xdsUpdateHealthServiceClient) SetNotServing(ctx context.Context, req *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error) {
	return c.setNotServing(ctx, req)
}

// XdsUpdateHealthServiceHandler is an implementation of the grpc.testing.XdsUpdateHealthService
// service.
type XdsUpdateHealthServiceHandler interface {
	SetServing(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
	SetNotServing(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error)
}

// NewXdsUpdateHealthServiceHandler builds an HTTP handler from the service implementation. It
// returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the gRPC and gRPC-Web protocols with the binary protobuf and JSON
// codecs.
func NewXdsUpdateHealthServiceHandler(svc XdsUpdateHealthServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	var lastHandlerPath string
	mux := http.NewServeMux()
	opts = append([]connect.HandlerOption{
		connect.WithProtoBinaryCodec(),
		connect.WithProtoJSONCodec(),
		connect.WithGzip(),
	}, opts...)

	setServing := connect.NewUnaryHandler(
		"grpc.testing.XdsUpdateHealthService/SetServing", // procedure name
		"grpc.testing.XdsUpdateHealthService",            // reflection name
		svc.SetServing,
		opts...,
	)
	mux.Handle(setServing.Path(), setServing)
	lastHandlerPath = setServing.Path()

	setNotServing := connect.NewUnaryHandler(
		"grpc.testing.XdsUpdateHealthService/SetNotServing", // procedure name
		"grpc.testing.XdsUpdateHealthService",               // reflection name
		svc.SetNotServing,
		opts...,
	)
	mux.Handle(setNotServing.Path(), setNotServing)
	lastHandlerPath = setNotServing.Path()

	return path.Dir(lastHandlerPath) + "/", mux
}

// UnimplementedXdsUpdateHealthServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedXdsUpdateHealthServiceHandler struct{}

var _ XdsUpdateHealthServiceHandler = (*UnimplementedXdsUpdateHealthServiceHandler)(nil) // verify interface implementation

func (UnimplementedXdsUpdateHealthServiceHandler) SetServing(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.XdsUpdateHealthService.SetServing isn't implemented"))
}

func (UnimplementedXdsUpdateHealthServiceHandler) SetNotServing(context.Context, *connect.Envelope[testing.Empty]) (*connect.Envelope[testing.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.XdsUpdateHealthService.SetNotServing isn't implemented"))
}

// XdsUpdateClientConfigureServiceClient is a client for the
// grpc.testing.XdsUpdateClientConfigureService service.
type XdsUpdateClientConfigureServiceClient interface {
	// Update the tes client's configuration.
	Configure(context.Context, *connect.Envelope[testing.ClientConfigureRequest]) (*connect.Envelope[testing.ClientConfigureResponse], error)
}

// NewXdsUpdateClientConfigureServiceClient constructs a client for the
// grpc.testing.XdsUpdateClientConfigureService service. By default, it uses the binary protobuf
// codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g., https://api.acme.com or
// https://acme.com/grpc).
func NewXdsUpdateClientConfigureServiceClient(baseURL string, doer connect.Doer, opts ...connect.ClientOption) (XdsUpdateClientConfigureServiceClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]connect.ClientOption{
		connect.WithProtoBinaryCodec(),
		connect.WithGzip(),
	}, opts...)
	var (
		client xdsUpdateClientConfigureServiceClient
		err    error
	)
	client.configure, err = connect.NewUnaryClientImplementation[testing.ClientConfigureRequest, testing.ClientConfigureResponse](
		doer,
		baseURL,
		"grpc.testing.XdsUpdateClientConfigureService/Configure",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &client, nil
}

// xdsUpdateClientConfigureServiceClient implements XdsUpdateClientConfigureServiceClient.
type xdsUpdateClientConfigureServiceClient struct {
	configure func(context.Context, *connect.Envelope[testing.ClientConfigureRequest]) (*connect.Envelope[testing.ClientConfigureResponse], error)
}

var _ XdsUpdateClientConfigureServiceClient = (*xdsUpdateClientConfigureServiceClient)(nil) // verify interface implementation

// Configure calls grpc.testing.XdsUpdateClientConfigureService.Configure.
func (c *xdsUpdateClientConfigureServiceClient) Configure(ctx context.Context, req *connect.Envelope[testing.ClientConfigureRequest]) (*connect.Envelope[testing.ClientConfigureResponse], error) {
	return c.configure(ctx, req)
}

// XdsUpdateClientConfigureServiceHandler is an implementation of the
// grpc.testing.XdsUpdateClientConfigureService service.
type XdsUpdateClientConfigureServiceHandler interface {
	// Update the tes client's configuration.
	Configure(context.Context, *connect.Envelope[testing.ClientConfigureRequest]) (*connect.Envelope[testing.ClientConfigureResponse], error)
}

// NewXdsUpdateClientConfigureServiceHandler builds an HTTP handler from the service implementation.
// It returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the gRPC and gRPC-Web protocols with the binary protobuf and JSON
// codecs.
func NewXdsUpdateClientConfigureServiceHandler(svc XdsUpdateClientConfigureServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	var lastHandlerPath string
	mux := http.NewServeMux()
	opts = append([]connect.HandlerOption{
		connect.WithProtoBinaryCodec(),
		connect.WithProtoJSONCodec(),
		connect.WithGzip(),
	}, opts...)

	configure := connect.NewUnaryHandler(
		"grpc.testing.XdsUpdateClientConfigureService/Configure", // procedure name
		"grpc.testing.XdsUpdateClientConfigureService",           // reflection name
		svc.Configure,
		opts...,
	)
	mux.Handle(configure.Path(), configure)
	lastHandlerPath = configure.Path()

	return path.Dir(lastHandlerPath) + "/", mux
}

// UnimplementedXdsUpdateClientConfigureServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedXdsUpdateClientConfigureServiceHandler struct{}

var _ XdsUpdateClientConfigureServiceHandler = (*UnimplementedXdsUpdateClientConfigureServiceHandler)(nil) // verify interface implementation

func (UnimplementedXdsUpdateClientConfigureServiceHandler) Configure(context.Context, *connect.Envelope[testing.ClientConfigureRequest]) (*connect.Envelope[testing.ClientConfigureResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("grpc.testing.XdsUpdateClientConfigureService.Configure isn't implemented"))
}
