// Copyright 2020-2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-connect. DO NOT EDIT.
// versions:
// - protoc-gen-go-connect v0.0.1
// - protoc              (unknown)
// source: grpc/testing/test.proto

package testing

import (
	context "context"
	connect "github.com/bufbuild/connect"
	testing "github.com/bufbuild/connect-crosstest/internal/gen/proto/go/grpc/testing"
	clientstream "github.com/bufbuild/connect/clientstream"
	protobuf "github.com/bufbuild/connect/codec/protobuf"
	protojson "github.com/bufbuild/connect/codec/protojson"
	gzip "github.com/bufbuild/connect/compress/gzip"
	handlerstream "github.com/bufbuild/connect/handlerstream"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the
// connect package are compatible. If you get a compiler error that this
// constant isn't defined, this code was generated with a version of connect
// newer than the one compiled into your binary. You can fix the problem by
// either regenerating this code with an older version of connect or updating
// the connect version compiled into your binary.
const _ = connect.IsAtLeastVersion0_0_1

// TestServiceClient is a client for the grpc.testing.TestService service.
type TestServiceClient interface {
	// One empty request followed by one empty response.
	EmptyCall(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
	// One request followed by one response.
	UnaryCall(context.Context, *connect.Request[testing.SimpleRequest]) (*connect.Response[testing.SimpleResponse], error)
	// One request followed by one response. Response has cache control
	// headers set such that a caching HTTP proxy (such as GFE) can
	// satisfy subsequent requests.
	CacheableUnaryCall(context.Context, *connect.Request[testing.SimpleRequest]) (*connect.Response[testing.SimpleResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	StreamingOutputCall(context.Context, *connect.Request[testing.StreamingOutputCallRequest]) (*clientstream.Server[testing.StreamingOutputCallResponse], error)
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the aggregated size of client payload as the result.
	StreamingInputCall(context.Context) *clientstream.Client[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse]
	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	FullDuplexCall(context.Context) *clientstream.Bidirectional[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client requests and then serves them in order. A
	// stream of responses are returned to the client when the server starts with
	// first request.
	HalfDuplexCall(context.Context) *clientstream.Bidirectional[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented methods.
	UnimplementedCall(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
}

// NewTestServiceClient constructs a client for the grpc.testing.TestService
// service. By default, it uses the binary protobuf codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g.,
// https://api.acme.com or https://acme.com/grpc).
func NewTestServiceClient(baseURL string, doer connect.Doer, opts ...connect.ClientOption) (TestServiceClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]connect.ClientOption{
		connect.WithGRPC(true),
		connect.WithCodec(protobuf.Name, protobuf.New()),
		connect.WithCompressor(gzip.Name, gzip.New()),
	}, opts...)
	var (
		client testServiceClient
		err    error
	)
	client.emptyCall, err = connect.NewClientFunc[testing.Empty, testing.Empty](
		doer,
		baseURL,
		"grpc.testing.TestService/EmptyCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.unaryCall, err = connect.NewClientFunc[testing.SimpleRequest, testing.SimpleResponse](
		doer,
		baseURL,
		"grpc.testing.TestService/UnaryCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.cacheableUnaryCall, err = connect.NewClientFunc[testing.SimpleRequest, testing.SimpleResponse](
		doer,
		baseURL,
		"grpc.testing.TestService/CacheableUnaryCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.streamingOutputCall, err = connect.NewClientStream(
		doer,
		connect.StreamTypeServer,
		baseURL,
		"grpc.testing.TestService/StreamingOutputCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.streamingInputCall, err = connect.NewClientStream(
		doer,
		connect.StreamTypeClient,
		baseURL,
		"grpc.testing.TestService/StreamingInputCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.fullDuplexCall, err = connect.NewClientStream(
		doer,
		connect.StreamTypeBidirectional,
		baseURL,
		"grpc.testing.TestService/FullDuplexCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.halfDuplexCall, err = connect.NewClientStream(
		doer,
		connect.StreamTypeBidirectional,
		baseURL,
		"grpc.testing.TestService/HalfDuplexCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.unimplementedCall, err = connect.NewClientFunc[testing.Empty, testing.Empty](
		doer,
		baseURL,
		"grpc.testing.TestService/UnimplementedCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &client, nil
}

// testServiceClient implements TestServiceClient.
type testServiceClient struct {
	emptyCall           func(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
	unaryCall           func(context.Context, *connect.Request[testing.SimpleRequest]) (*connect.Response[testing.SimpleResponse], error)
	cacheableUnaryCall  func(context.Context, *connect.Request[testing.SimpleRequest]) (*connect.Response[testing.SimpleResponse], error)
	streamingOutputCall func(context.Context) (connect.Sender, connect.Receiver)
	streamingInputCall  func(context.Context) (connect.Sender, connect.Receiver)
	fullDuplexCall      func(context.Context) (connect.Sender, connect.Receiver)
	halfDuplexCall      func(context.Context) (connect.Sender, connect.Receiver)
	unimplementedCall   func(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
}

var _ TestServiceClient = (*testServiceClient)(nil) // verify interface implementation

// EmptyCall calls grpc.testing.TestService.EmptyCall.
func (c *testServiceClient) EmptyCall(ctx context.Context, req *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error) {
	return c.emptyCall(ctx, req)
}

// UnaryCall calls grpc.testing.TestService.UnaryCall.
func (c *testServiceClient) UnaryCall(ctx context.Context, req *connect.Request[testing.SimpleRequest]) (*connect.Response[testing.SimpleResponse], error) {
	return c.unaryCall(ctx, req)
}

// CacheableUnaryCall calls grpc.testing.TestService.CacheableUnaryCall.
func (c *testServiceClient) CacheableUnaryCall(ctx context.Context, req *connect.Request[testing.SimpleRequest]) (*connect.Response[testing.SimpleResponse], error) {
	return c.cacheableUnaryCall(ctx, req)
}

// StreamingOutputCall calls grpc.testing.TestService.StreamingOutputCall.
func (c *testServiceClient) StreamingOutputCall(ctx context.Context, req *connect.Request[testing.StreamingOutputCallRequest]) (*clientstream.Server[testing.StreamingOutputCallResponse], error) {
	sender, receiver := c.streamingOutputCall(ctx)
	if err := sender.Send(req.Msg); err != nil {
		_ = sender.Close(err)
		_ = receiver.Close()
		return nil, err
	}
	if err := sender.Close(nil); err != nil {
		_ = receiver.Close()
		return nil, err
	}
	return clientstream.NewServer[testing.StreamingOutputCallResponse](receiver), nil
}

// StreamingInputCall calls grpc.testing.TestService.StreamingInputCall.
func (c *testServiceClient) StreamingInputCall(ctx context.Context) *clientstream.Client[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse] {
	sender, receiver := c.streamingInputCall(ctx)
	return clientstream.NewClient[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse](sender, receiver)
}

// FullDuplexCall calls grpc.testing.TestService.FullDuplexCall.
func (c *testServiceClient) FullDuplexCall(ctx context.Context) *clientstream.Bidirectional[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse] {
	sender, receiver := c.fullDuplexCall(ctx)
	return clientstream.NewBidirectional[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](sender, receiver)
}

// HalfDuplexCall calls grpc.testing.TestService.HalfDuplexCall.
func (c *testServiceClient) HalfDuplexCall(ctx context.Context) *clientstream.Bidirectional[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse] {
	sender, receiver := c.halfDuplexCall(ctx)
	return clientstream.NewBidirectional[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](sender, receiver)
}

// UnimplementedCall calls grpc.testing.TestService.UnimplementedCall.
func (c *testServiceClient) UnimplementedCall(ctx context.Context, req *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error) {
	return c.unimplementedCall(ctx, req)
}

// TestServiceHandler is an implementation of the grpc.testing.TestService
// service.
type TestServiceHandler interface {
	// One empty request followed by one empty response.
	EmptyCall(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
	// One request followed by one response.
	UnaryCall(context.Context, *connect.Request[testing.SimpleRequest]) (*connect.Response[testing.SimpleResponse], error)
	// One request followed by one response. Response has cache control
	// headers set such that a caching HTTP proxy (such as GFE) can
	// satisfy subsequent requests.
	CacheableUnaryCall(context.Context, *connect.Request[testing.SimpleRequest]) (*connect.Response[testing.SimpleResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	StreamingOutputCall(context.Context, *connect.Request[testing.StreamingOutputCallRequest], *handlerstream.Server[testing.StreamingOutputCallResponse]) error
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the aggregated size of client payload as the result.
	StreamingInputCall(context.Context, *handlerstream.Client[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse]) error
	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	FullDuplexCall(context.Context, *handlerstream.Bidirectional[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client requests and then serves them in order. A
	// stream of responses are returned to the client when the server starts with
	// first request.
	HalfDuplexCall(context.Context, *handlerstream.Bidirectional[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented methods.
	UnimplementedCall(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
}

// WithTestServiceHandler wraps the service implementation in a
// connect.MuxOption, which can then be passed to connect.NewServeMux.
//
// By default, services support the gRPC and gRPC-Web protocols with the binary
// protobuf and JSON codecs.
func WithTestServiceHandler(svc TestServiceHandler, opts ...connect.HandlerOption) connect.MuxOption {
	handlers := make([]connect.Handler, 0, 8)
	opts = append([]connect.HandlerOption{
		connect.WithGRPC(true),
		connect.WithGRPCWeb(true),
		connect.WithCodec(protobuf.Name, protobuf.New()),
		connect.WithCodec(protojson.Name, protojson.New()),
		connect.WithCompressor(gzip.Name, gzip.New()),
	}, opts...)

	emptyCall, err := connect.NewUnaryHandler(
		"grpc.testing.TestService/EmptyCall", // procedure name
		"grpc.testing.TestService",           // reflection name
		svc.EmptyCall,
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *emptyCall)

	unaryCall, err := connect.NewUnaryHandler(
		"grpc.testing.TestService/UnaryCall", // procedure name
		"grpc.testing.TestService",           // reflection name
		svc.UnaryCall,
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *unaryCall)

	cacheableUnaryCall, err := connect.NewUnaryHandler(
		"grpc.testing.TestService/CacheableUnaryCall", // procedure name
		"grpc.testing.TestService",                    // reflection name
		svc.CacheableUnaryCall,
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *cacheableUnaryCall)

	streamingOutputCall, err := connect.NewStreamingHandler(
		connect.StreamTypeServer,
		"grpc.testing.TestService/StreamingOutputCall", // procedure name
		"grpc.testing.TestService",                     // reflection name
		func(ctx context.Context, sender connect.Sender, receiver connect.Receiver) {
			typed := handlerstream.NewServer[testing.StreamingOutputCallResponse](sender)
			req, err := connect.ReceiveRequest[testing.StreamingOutputCallRequest](receiver)
			if err != nil {
				_ = receiver.Close()
				_ = sender.Close(err)
				return
			}
			if err = receiver.Close(); err != nil {
				_ = sender.Close(err)
				return
			}
			err = svc.StreamingOutputCall(ctx, req, typed)
			_ = sender.Close(err)
		},
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *streamingOutputCall)

	streamingInputCall, err := connect.NewStreamingHandler(
		connect.StreamTypeClient,
		"grpc.testing.TestService/StreamingInputCall", // procedure name
		"grpc.testing.TestService",                    // reflection name
		func(ctx context.Context, sender connect.Sender, receiver connect.Receiver) {
			typed := handlerstream.NewClient[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse](sender, receiver)
			err := svc.StreamingInputCall(ctx, typed)
			_ = receiver.Close()
			_ = sender.Close(err)
		},
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *streamingInputCall)

	fullDuplexCall, err := connect.NewStreamingHandler(
		connect.StreamTypeBidirectional,
		"grpc.testing.TestService/FullDuplexCall", // procedure name
		"grpc.testing.TestService",                // reflection name
		func(ctx context.Context, sender connect.Sender, receiver connect.Receiver) {
			typed := handlerstream.NewBidirectional[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](sender, receiver)
			err := svc.FullDuplexCall(ctx, typed)
			_ = receiver.Close()
			_ = sender.Close(err)
		},
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *fullDuplexCall)

	halfDuplexCall, err := connect.NewStreamingHandler(
		connect.StreamTypeBidirectional,
		"grpc.testing.TestService/HalfDuplexCall", // procedure name
		"grpc.testing.TestService",                // reflection name
		func(ctx context.Context, sender connect.Sender, receiver connect.Receiver) {
			typed := handlerstream.NewBidirectional[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](sender, receiver)
			err := svc.HalfDuplexCall(ctx, typed)
			_ = receiver.Close()
			_ = sender.Close(err)
		},
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *halfDuplexCall)

	unimplementedCall, err := connect.NewUnaryHandler(
		"grpc.testing.TestService/UnimplementedCall", // procedure name
		"grpc.testing.TestService",                   // reflection name
		svc.UnimplementedCall,
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *unimplementedCall)

	return connect.WithHandlers(handlers, nil)
}

// UnimplementedTestServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedTestServiceHandler struct{}

var _ TestServiceHandler = (*UnimplementedTestServiceHandler)(nil) // verify interface implementation

func (UnimplementedTestServiceHandler) EmptyCall(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error) {
	return nil, connect.Errorf(connect.CodeUnimplemented, "grpc.testing.TestService.EmptyCall isn't implemented")
}

func (UnimplementedTestServiceHandler) UnaryCall(context.Context, *connect.Request[testing.SimpleRequest]) (*connect.Response[testing.SimpleResponse], error) {
	return nil, connect.Errorf(connect.CodeUnimplemented, "grpc.testing.TestService.UnaryCall isn't implemented")
}

func (UnimplementedTestServiceHandler) CacheableUnaryCall(context.Context, *connect.Request[testing.SimpleRequest]) (*connect.Response[testing.SimpleResponse], error) {
	return nil, connect.Errorf(connect.CodeUnimplemented, "grpc.testing.TestService.CacheableUnaryCall isn't implemented")
}

func (UnimplementedTestServiceHandler) StreamingOutputCall(context.Context, *connect.Request[testing.StreamingOutputCallRequest], *handlerstream.Server[testing.StreamingOutputCallResponse]) error {
	return connect.Errorf(connect.CodeUnimplemented, "grpc.testing.TestService.StreamingOutputCall isn't implemented")
}

func (UnimplementedTestServiceHandler) StreamingInputCall(context.Context, *handlerstream.Client[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse]) error {
	return connect.Errorf(connect.CodeUnimplemented, "grpc.testing.TestService.StreamingInputCall isn't implemented")
}

func (UnimplementedTestServiceHandler) FullDuplexCall(context.Context, *handlerstream.Bidirectional[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error {
	return connect.Errorf(connect.CodeUnimplemented, "grpc.testing.TestService.FullDuplexCall isn't implemented")
}

func (UnimplementedTestServiceHandler) HalfDuplexCall(context.Context, *handlerstream.Bidirectional[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error {
	return connect.Errorf(connect.CodeUnimplemented, "grpc.testing.TestService.HalfDuplexCall isn't implemented")
}

func (UnimplementedTestServiceHandler) UnimplementedCall(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error) {
	return nil, connect.Errorf(connect.CodeUnimplemented, "grpc.testing.TestService.UnimplementedCall isn't implemented")
}

// UnimplementedServiceClient is a client for the
// grpc.testing.UnimplementedService service.
type UnimplementedServiceClient interface {
	// A call that no server should implement
	UnimplementedCall(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
}

// NewUnimplementedServiceClient constructs a client for the
// grpc.testing.UnimplementedService service. By default, it uses the binary
// protobuf codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g.,
// https://api.acme.com or https://acme.com/grpc).
func NewUnimplementedServiceClient(baseURL string, doer connect.Doer, opts ...connect.ClientOption) (UnimplementedServiceClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]connect.ClientOption{
		connect.WithGRPC(true),
		connect.WithCodec(protobuf.Name, protobuf.New()),
		connect.WithCompressor(gzip.Name, gzip.New()),
	}, opts...)
	var (
		client unimplementedServiceClient
		err    error
	)
	client.unimplementedCall, err = connect.NewClientFunc[testing.Empty, testing.Empty](
		doer,
		baseURL,
		"grpc.testing.UnimplementedService/UnimplementedCall",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &client, nil
}

// unimplementedServiceClient implements UnimplementedServiceClient.
type unimplementedServiceClient struct {
	unimplementedCall func(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
}

var _ UnimplementedServiceClient = (*unimplementedServiceClient)(nil) // verify interface implementation

// UnimplementedCall calls grpc.testing.UnimplementedService.UnimplementedCall.
func (c *unimplementedServiceClient) UnimplementedCall(ctx context.Context, req *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error) {
	return c.unimplementedCall(ctx, req)
}

// UnimplementedServiceHandler is an implementation of the
// grpc.testing.UnimplementedService service.
type UnimplementedServiceHandler interface {
	// A call that no server should implement
	UnimplementedCall(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
}

// WithUnimplementedServiceHandler wraps the service implementation in a
// connect.MuxOption, which can then be passed to connect.NewServeMux.
//
// By default, services support the gRPC and gRPC-Web protocols with the binary
// protobuf and JSON codecs.
func WithUnimplementedServiceHandler(svc UnimplementedServiceHandler, opts ...connect.HandlerOption) connect.MuxOption {
	handlers := make([]connect.Handler, 0, 1)
	opts = append([]connect.HandlerOption{
		connect.WithGRPC(true),
		connect.WithGRPCWeb(true),
		connect.WithCodec(protobuf.Name, protobuf.New()),
		connect.WithCodec(protojson.Name, protojson.New()),
		connect.WithCompressor(gzip.Name, gzip.New()),
	}, opts...)

	unimplementedCall, err := connect.NewUnaryHandler(
		"grpc.testing.UnimplementedService/UnimplementedCall", // procedure name
		"grpc.testing.UnimplementedService",                   // reflection name
		svc.UnimplementedCall,
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *unimplementedCall)

	return connect.WithHandlers(handlers, nil)
}

// UnimplementedUnimplementedServiceHandler returns CodeUnimplemented from all
// methods.
type UnimplementedUnimplementedServiceHandler struct{}

var _ UnimplementedServiceHandler = (*UnimplementedUnimplementedServiceHandler)(nil) // verify interface implementation

func (UnimplementedUnimplementedServiceHandler) UnimplementedCall(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error) {
	return nil, connect.Errorf(connect.CodeUnimplemented, "grpc.testing.UnimplementedService.UnimplementedCall isn't implemented")
}

// ReconnectServiceClient is a client for the grpc.testing.ReconnectService
// service.
type ReconnectServiceClient interface {
	Start(context.Context, *connect.Request[testing.ReconnectParams]) (*connect.Response[testing.Empty], error)
	Stop(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.ReconnectInfo], error)
}

// NewReconnectServiceClient constructs a client for the
// grpc.testing.ReconnectService service. By default, it uses the binary
// protobuf codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g.,
// https://api.acme.com or https://acme.com/grpc).
func NewReconnectServiceClient(baseURL string, doer connect.Doer, opts ...connect.ClientOption) (ReconnectServiceClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]connect.ClientOption{
		connect.WithGRPC(true),
		connect.WithCodec(protobuf.Name, protobuf.New()),
		connect.WithCompressor(gzip.Name, gzip.New()),
	}, opts...)
	var (
		client reconnectServiceClient
		err    error
	)
	client.start, err = connect.NewClientFunc[testing.ReconnectParams, testing.Empty](
		doer,
		baseURL,
		"grpc.testing.ReconnectService/Start",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.stop, err = connect.NewClientFunc[testing.Empty, testing.ReconnectInfo](
		doer,
		baseURL,
		"grpc.testing.ReconnectService/Stop",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &client, nil
}

// reconnectServiceClient implements ReconnectServiceClient.
type reconnectServiceClient struct {
	start func(context.Context, *connect.Request[testing.ReconnectParams]) (*connect.Response[testing.Empty], error)
	stop  func(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.ReconnectInfo], error)
}

var _ ReconnectServiceClient = (*reconnectServiceClient)(nil) // verify interface implementation

// Start calls grpc.testing.ReconnectService.Start.
func (c *reconnectServiceClient) Start(ctx context.Context, req *connect.Request[testing.ReconnectParams]) (*connect.Response[testing.Empty], error) {
	return c.start(ctx, req)
}

// Stop calls grpc.testing.ReconnectService.Stop.
func (c *reconnectServiceClient) Stop(ctx context.Context, req *connect.Request[testing.Empty]) (*connect.Response[testing.ReconnectInfo], error) {
	return c.stop(ctx, req)
}

// ReconnectServiceHandler is an implementation of the
// grpc.testing.ReconnectService service.
type ReconnectServiceHandler interface {
	Start(context.Context, *connect.Request[testing.ReconnectParams]) (*connect.Response[testing.Empty], error)
	Stop(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.ReconnectInfo], error)
}

// WithReconnectServiceHandler wraps the service implementation in a
// connect.MuxOption, which can then be passed to connect.NewServeMux.
//
// By default, services support the gRPC and gRPC-Web protocols with the binary
// protobuf and JSON codecs.
func WithReconnectServiceHandler(svc ReconnectServiceHandler, opts ...connect.HandlerOption) connect.MuxOption {
	handlers := make([]connect.Handler, 0, 2)
	opts = append([]connect.HandlerOption{
		connect.WithGRPC(true),
		connect.WithGRPCWeb(true),
		connect.WithCodec(protobuf.Name, protobuf.New()),
		connect.WithCodec(protojson.Name, protojson.New()),
		connect.WithCompressor(gzip.Name, gzip.New()),
	}, opts...)

	start, err := connect.NewUnaryHandler(
		"grpc.testing.ReconnectService/Start", // procedure name
		"grpc.testing.ReconnectService",       // reflection name
		svc.Start,
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *start)

	stop, err := connect.NewUnaryHandler(
		"grpc.testing.ReconnectService/Stop", // procedure name
		"grpc.testing.ReconnectService",      // reflection name
		svc.Stop,
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *stop)

	return connect.WithHandlers(handlers, nil)
}

// UnimplementedReconnectServiceHandler returns CodeUnimplemented from all
// methods.
type UnimplementedReconnectServiceHandler struct{}

var _ ReconnectServiceHandler = (*UnimplementedReconnectServiceHandler)(nil) // verify interface implementation

func (UnimplementedReconnectServiceHandler) Start(context.Context, *connect.Request[testing.ReconnectParams]) (*connect.Response[testing.Empty], error) {
	return nil, connect.Errorf(connect.CodeUnimplemented, "grpc.testing.ReconnectService.Start isn't implemented")
}

func (UnimplementedReconnectServiceHandler) Stop(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.ReconnectInfo], error) {
	return nil, connect.Errorf(connect.CodeUnimplemented, "grpc.testing.ReconnectService.Stop isn't implemented")
}

// LoadBalancerStatsServiceClient is a client for the
// grpc.testing.LoadBalancerStatsService service.
type LoadBalancerStatsServiceClient interface {
	// Gets the backend distribution for RPCs sent by a test client.
	GetClientStats(context.Context, *connect.Request[testing.LoadBalancerStatsRequest]) (*connect.Response[testing.LoadBalancerStatsResponse], error)
	// Gets the accumulated stats for RPCs sent by a test client.
	GetClientAccumulatedStats(context.Context, *connect.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect.Response[testing.LoadBalancerAccumulatedStatsResponse], error)
}

// NewLoadBalancerStatsServiceClient constructs a client for the
// grpc.testing.LoadBalancerStatsService service. By default, it uses the binary
// protobuf codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g.,
// https://api.acme.com or https://acme.com/grpc).
func NewLoadBalancerStatsServiceClient(baseURL string, doer connect.Doer, opts ...connect.ClientOption) (LoadBalancerStatsServiceClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]connect.ClientOption{
		connect.WithGRPC(true),
		connect.WithCodec(protobuf.Name, protobuf.New()),
		connect.WithCompressor(gzip.Name, gzip.New()),
	}, opts...)
	var (
		client loadBalancerStatsServiceClient
		err    error
	)
	client.getClientStats, err = connect.NewClientFunc[testing.LoadBalancerStatsRequest, testing.LoadBalancerStatsResponse](
		doer,
		baseURL,
		"grpc.testing.LoadBalancerStatsService/GetClientStats",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.getClientAccumulatedStats, err = connect.NewClientFunc[testing.LoadBalancerAccumulatedStatsRequest, testing.LoadBalancerAccumulatedStatsResponse](
		doer,
		baseURL,
		"grpc.testing.LoadBalancerStatsService/GetClientAccumulatedStats",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &client, nil
}

// loadBalancerStatsServiceClient implements LoadBalancerStatsServiceClient.
type loadBalancerStatsServiceClient struct {
	getClientStats            func(context.Context, *connect.Request[testing.LoadBalancerStatsRequest]) (*connect.Response[testing.LoadBalancerStatsResponse], error)
	getClientAccumulatedStats func(context.Context, *connect.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect.Response[testing.LoadBalancerAccumulatedStatsResponse], error)
}

var _ LoadBalancerStatsServiceClient = (*loadBalancerStatsServiceClient)(nil) // verify interface implementation

// GetClientStats calls grpc.testing.LoadBalancerStatsService.GetClientStats.
func (c *loadBalancerStatsServiceClient) GetClientStats(ctx context.Context, req *connect.Request[testing.LoadBalancerStatsRequest]) (*connect.Response[testing.LoadBalancerStatsResponse], error) {
	return c.getClientStats(ctx, req)
}

// GetClientAccumulatedStats calls
// grpc.testing.LoadBalancerStatsService.GetClientAccumulatedStats.
func (c *loadBalancerStatsServiceClient) GetClientAccumulatedStats(ctx context.Context, req *connect.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect.Response[testing.LoadBalancerAccumulatedStatsResponse], error) {
	return c.getClientAccumulatedStats(ctx, req)
}

// LoadBalancerStatsServiceHandler is an implementation of the
// grpc.testing.LoadBalancerStatsService service.
type LoadBalancerStatsServiceHandler interface {
	// Gets the backend distribution for RPCs sent by a test client.
	GetClientStats(context.Context, *connect.Request[testing.LoadBalancerStatsRequest]) (*connect.Response[testing.LoadBalancerStatsResponse], error)
	// Gets the accumulated stats for RPCs sent by a test client.
	GetClientAccumulatedStats(context.Context, *connect.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect.Response[testing.LoadBalancerAccumulatedStatsResponse], error)
}

// WithLoadBalancerStatsServiceHandler wraps the service implementation in a
// connect.MuxOption, which can then be passed to connect.NewServeMux.
//
// By default, services support the gRPC and gRPC-Web protocols with the binary
// protobuf and JSON codecs.
func WithLoadBalancerStatsServiceHandler(svc LoadBalancerStatsServiceHandler, opts ...connect.HandlerOption) connect.MuxOption {
	handlers := make([]connect.Handler, 0, 2)
	opts = append([]connect.HandlerOption{
		connect.WithGRPC(true),
		connect.WithGRPCWeb(true),
		connect.WithCodec(protobuf.Name, protobuf.New()),
		connect.WithCodec(protojson.Name, protojson.New()),
		connect.WithCompressor(gzip.Name, gzip.New()),
	}, opts...)

	getClientStats, err := connect.NewUnaryHandler(
		"grpc.testing.LoadBalancerStatsService/GetClientStats", // procedure name
		"grpc.testing.LoadBalancerStatsService",                // reflection name
		svc.GetClientStats,
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *getClientStats)

	getClientAccumulatedStats, err := connect.NewUnaryHandler(
		"grpc.testing.LoadBalancerStatsService/GetClientAccumulatedStats", // procedure name
		"grpc.testing.LoadBalancerStatsService",                           // reflection name
		svc.GetClientAccumulatedStats,
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *getClientAccumulatedStats)

	return connect.WithHandlers(handlers, nil)
}

// UnimplementedLoadBalancerStatsServiceHandler returns CodeUnimplemented from
// all methods.
type UnimplementedLoadBalancerStatsServiceHandler struct{}

var _ LoadBalancerStatsServiceHandler = (*UnimplementedLoadBalancerStatsServiceHandler)(nil) // verify interface implementation

func (UnimplementedLoadBalancerStatsServiceHandler) GetClientStats(context.Context, *connect.Request[testing.LoadBalancerStatsRequest]) (*connect.Response[testing.LoadBalancerStatsResponse], error) {
	return nil, connect.Errorf(connect.CodeUnimplemented, "grpc.testing.LoadBalancerStatsService.GetClientStats isn't implemented")
}

func (UnimplementedLoadBalancerStatsServiceHandler) GetClientAccumulatedStats(context.Context, *connect.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect.Response[testing.LoadBalancerAccumulatedStatsResponse], error) {
	return nil, connect.Errorf(connect.CodeUnimplemented, "grpc.testing.LoadBalancerStatsService.GetClientAccumulatedStats isn't implemented")
}

// XdsUpdateHealthServiceClient is a client for the
// grpc.testing.XdsUpdateHealthService service.
type XdsUpdateHealthServiceClient interface {
	SetServing(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
	SetNotServing(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
}

// NewXdsUpdateHealthServiceClient constructs a client for the
// grpc.testing.XdsUpdateHealthService service. By default, it uses the binary
// protobuf codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g.,
// https://api.acme.com or https://acme.com/grpc).
func NewXdsUpdateHealthServiceClient(baseURL string, doer connect.Doer, opts ...connect.ClientOption) (XdsUpdateHealthServiceClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]connect.ClientOption{
		connect.WithGRPC(true),
		connect.WithCodec(protobuf.Name, protobuf.New()),
		connect.WithCompressor(gzip.Name, gzip.New()),
	}, opts...)
	var (
		client xdsUpdateHealthServiceClient
		err    error
	)
	client.setServing, err = connect.NewClientFunc[testing.Empty, testing.Empty](
		doer,
		baseURL,
		"grpc.testing.XdsUpdateHealthService/SetServing",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	client.setNotServing, err = connect.NewClientFunc[testing.Empty, testing.Empty](
		doer,
		baseURL,
		"grpc.testing.XdsUpdateHealthService/SetNotServing",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &client, nil
}

// xdsUpdateHealthServiceClient implements XdsUpdateHealthServiceClient.
type xdsUpdateHealthServiceClient struct {
	setServing    func(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
	setNotServing func(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
}

var _ XdsUpdateHealthServiceClient = (*xdsUpdateHealthServiceClient)(nil) // verify interface implementation

// SetServing calls grpc.testing.XdsUpdateHealthService.SetServing.
func (c *xdsUpdateHealthServiceClient) SetServing(ctx context.Context, req *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error) {
	return c.setServing(ctx, req)
}

// SetNotServing calls grpc.testing.XdsUpdateHealthService.SetNotServing.
func (c *xdsUpdateHealthServiceClient) SetNotServing(ctx context.Context, req *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error) {
	return c.setNotServing(ctx, req)
}

// XdsUpdateHealthServiceHandler is an implementation of the
// grpc.testing.XdsUpdateHealthService service.
type XdsUpdateHealthServiceHandler interface {
	SetServing(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
	SetNotServing(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error)
}

// WithXdsUpdateHealthServiceHandler wraps the service implementation in a
// connect.MuxOption, which can then be passed to connect.NewServeMux.
//
// By default, services support the gRPC and gRPC-Web protocols with the binary
// protobuf and JSON codecs.
func WithXdsUpdateHealthServiceHandler(svc XdsUpdateHealthServiceHandler, opts ...connect.HandlerOption) connect.MuxOption {
	handlers := make([]connect.Handler, 0, 2)
	opts = append([]connect.HandlerOption{
		connect.WithGRPC(true),
		connect.WithGRPCWeb(true),
		connect.WithCodec(protobuf.Name, protobuf.New()),
		connect.WithCodec(protojson.Name, protojson.New()),
		connect.WithCompressor(gzip.Name, gzip.New()),
	}, opts...)

	setServing, err := connect.NewUnaryHandler(
		"grpc.testing.XdsUpdateHealthService/SetServing", // procedure name
		"grpc.testing.XdsUpdateHealthService",            // reflection name
		svc.SetServing,
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *setServing)

	setNotServing, err := connect.NewUnaryHandler(
		"grpc.testing.XdsUpdateHealthService/SetNotServing", // procedure name
		"grpc.testing.XdsUpdateHealthService",               // reflection name
		svc.SetNotServing,
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *setNotServing)

	return connect.WithHandlers(handlers, nil)
}

// UnimplementedXdsUpdateHealthServiceHandler returns CodeUnimplemented from all
// methods.
type UnimplementedXdsUpdateHealthServiceHandler struct{}

var _ XdsUpdateHealthServiceHandler = (*UnimplementedXdsUpdateHealthServiceHandler)(nil) // verify interface implementation

func (UnimplementedXdsUpdateHealthServiceHandler) SetServing(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error) {
	return nil, connect.Errorf(connect.CodeUnimplemented, "grpc.testing.XdsUpdateHealthService.SetServing isn't implemented")
}

func (UnimplementedXdsUpdateHealthServiceHandler) SetNotServing(context.Context, *connect.Request[testing.Empty]) (*connect.Response[testing.Empty], error) {
	return nil, connect.Errorf(connect.CodeUnimplemented, "grpc.testing.XdsUpdateHealthService.SetNotServing isn't implemented")
}

// XdsUpdateClientConfigureServiceClient is a client for the
// grpc.testing.XdsUpdateClientConfigureService service.
type XdsUpdateClientConfigureServiceClient interface {
	// Update the tes client's configuration.
	Configure(context.Context, *connect.Request[testing.ClientConfigureRequest]) (*connect.Response[testing.ClientConfigureResponse], error)
}

// NewXdsUpdateClientConfigureServiceClient constructs a client for the
// grpc.testing.XdsUpdateClientConfigureService service. By default, it uses the
// binary protobuf codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g.,
// https://api.acme.com or https://acme.com/grpc).
func NewXdsUpdateClientConfigureServiceClient(baseURL string, doer connect.Doer, opts ...connect.ClientOption) (XdsUpdateClientConfigureServiceClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]connect.ClientOption{
		connect.WithGRPC(true),
		connect.WithCodec(protobuf.Name, protobuf.New()),
		connect.WithCompressor(gzip.Name, gzip.New()),
	}, opts...)
	var (
		client xdsUpdateClientConfigureServiceClient
		err    error
	)
	client.configure, err = connect.NewClientFunc[testing.ClientConfigureRequest, testing.ClientConfigureResponse](
		doer,
		baseURL,
		"grpc.testing.XdsUpdateClientConfigureService/Configure",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &client, nil
}

// xdsUpdateClientConfigureServiceClient implements
// XdsUpdateClientConfigureServiceClient.
type xdsUpdateClientConfigureServiceClient struct {
	configure func(context.Context, *connect.Request[testing.ClientConfigureRequest]) (*connect.Response[testing.ClientConfigureResponse], error)
}

var _ XdsUpdateClientConfigureServiceClient = (*xdsUpdateClientConfigureServiceClient)(nil) // verify interface implementation

// Configure calls grpc.testing.XdsUpdateClientConfigureService.Configure.
func (c *xdsUpdateClientConfigureServiceClient) Configure(ctx context.Context, req *connect.Request[testing.ClientConfigureRequest]) (*connect.Response[testing.ClientConfigureResponse], error) {
	return c.configure(ctx, req)
}

// XdsUpdateClientConfigureServiceHandler is an implementation of the
// grpc.testing.XdsUpdateClientConfigureService service.
type XdsUpdateClientConfigureServiceHandler interface {
	// Update the tes client's configuration.
	Configure(context.Context, *connect.Request[testing.ClientConfigureRequest]) (*connect.Response[testing.ClientConfigureResponse], error)
}

// WithXdsUpdateClientConfigureServiceHandler wraps the service implementation
// in a connect.MuxOption, which can then be passed to connect.NewServeMux.
//
// By default, services support the gRPC and gRPC-Web protocols with the binary
// protobuf and JSON codecs.
func WithXdsUpdateClientConfigureServiceHandler(svc XdsUpdateClientConfigureServiceHandler, opts ...connect.HandlerOption) connect.MuxOption {
	handlers := make([]connect.Handler, 0, 1)
	opts = append([]connect.HandlerOption{
		connect.WithGRPC(true),
		connect.WithGRPCWeb(true),
		connect.WithCodec(protobuf.Name, protobuf.New()),
		connect.WithCodec(protojson.Name, protojson.New()),
		connect.WithCompressor(gzip.Name, gzip.New()),
	}, opts...)

	configure, err := connect.NewUnaryHandler(
		"grpc.testing.XdsUpdateClientConfigureService/Configure", // procedure name
		"grpc.testing.XdsUpdateClientConfigureService",           // reflection name
		svc.Configure,
		opts...,
	)
	if err != nil {
		return connect.WithHandlers(nil, err)
	}
	handlers = append(handlers, *configure)

	return connect.WithHandlers(handlers, nil)
}

// UnimplementedXdsUpdateClientConfigureServiceHandler returns CodeUnimplemented
// from all methods.
type UnimplementedXdsUpdateClientConfigureServiceHandler struct{}

var _ XdsUpdateClientConfigureServiceHandler = (*UnimplementedXdsUpdateClientConfigureServiceHandler)(nil) // verify interface implementation

func (UnimplementedXdsUpdateClientConfigureServiceHandler) Configure(context.Context, *connect.Request[testing.ClientConfigureRequest]) (*connect.Response[testing.ClientConfigureResponse], error) {
	return nil, connect.Errorf(connect.CodeUnimplemented, "grpc.testing.XdsUpdateClientConfigureService.Configure isn't implemented")
}
